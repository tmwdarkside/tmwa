From 6b3c574c148a1a0f2ce23afd7770bd8a9867e042 Mon Sep 17 00:00:00 2001
From: Andrei Karas <akaras@inbox.ru>
Date: Wed, 15 Dec 2010 04:07:37 +0200
Subject: [PATCH 102/226] Port more service functions from eathena.

Port script function getmapxy.
---
 src/common/Makefile     |    4 +-
 src/common/cbasetypes.h |  340 ++++++++++++++++
 src/common/malloc.c     |    9 +
 src/common/malloc.h     |    9 +
 src/common/mmo.h        |    2 +
 src/common/showmsg.c    |  855 ++++++++++++++++++++++++++++++++++++++
 src/common/showmsg.h    |   95 +++++
 src/common/strlib.c     | 1037 +++++++++++++++++++++++++++++++++++++++++++++++
 src/common/strlib.h     |  124 ++++++
 src/map/Makefile        |    2 +-
 src/map/script.c        |  159 ++++++++
 11 files changed, 2634 insertions(+), 2 deletions(-)
 create mode 100644 src/common/cbasetypes.h
 create mode 100644 src/common/showmsg.c
 create mode 100644 src/common/showmsg.h
 create mode 100644 src/common/strlib.c
 create mode 100644 src/common/strlib.h

diff --git a/src/common/Makefile b/src/common/Makefile
index 27930bd..ba677b2 100644
--- a/src/common/Makefile
+++ b/src/common/Makefile
@@ -1,5 +1,5 @@
 include ../../make.defs
-txt sql all: core.o socket.o timer.o grfio.o db.o lock.o nullpo.o malloc.o mt_rand.o md5calc.o
+txt sql all: core.o socket.o timer.o grfio.o db.o lock.o nullpo.o malloc.o showmsg.o strlib.o mt_rand.o md5calc.o
 
 core.o: core.c core.h
 socket.o: socket.c socket.h mmo.h
@@ -9,6 +9,8 @@ db.o: db.c db.h
 lock.o: lock.h
 nullpo.o: nullpo.c nullpo.h
 malloc.o: malloc.c malloc.h
+showmsg.o: showmsg.c showmsg.h
+strlib.o: strlib.c strlib.h
 mt_rand.o: mt_rand.c mt_rand.h
 md5calc.o: md5calc.c md5calc.h
 
diff --git a/src/common/cbasetypes.h b/src/common/cbasetypes.h
new file mode 100644
index 0000000..f94e9c6
--- /dev/null
+++ b/src/common/cbasetypes.h
@@ -0,0 +1,340 @@
+#ifndef _CBASETYPES_H_
+#define _CBASETYPES_H_
+
+/*              +--------+-----------+--------+---------+
+ *              | ILP32  |   LP64    |  ILP64 | (LL)P64 |
+ * +------------+--------+-----------+--------+---------+
+ * | ints       | 32-bit |   32-bit  | 64-bit |  32-bit |
+ * | longs      | 32-bit |   64-bit  | 64-bit |  32-bit |
+ * | long-longs | 64-bit |   64-bit  | 64-bit |  64-bit |
+ * | pointers   | 32-bit |   64-bit  | 64-bit |  64-bit |
+ * +------------+--------+-----------+--------+---------+
+ * |    where   |   --   |   Tiger   |  Alpha | Windows |
+ * |    used    |        |   Unix    |  Cray  |         |
+ * |            |        | Sun & SGI |        |         |
+ * +------------+--------+-----------+--------+---------+
+ * Taken from http://developer.apple.com/macosx/64bit.html
+ */
+
+//////////////////////////////////////////////////////////////////////////
+// basic include for all basics
+// introduces types and global functions
+//////////////////////////////////////////////////////////////////////////
+
+
+//////////////////////////////////////////////////////////////////////////
+// setting some defines on platforms
+//////////////////////////////////////////////////////////////////////////
+#if (defined(__WIN32__) || defined(__WIN32) || defined(_WIN32) || defined(_WIN64) || defined(_MSC_VER) || defined(__BORLANDC__)) && !defined(WIN32)
+#define WIN32
+#endif
+
+#if defined(__MINGW32__) && !defined(MINGW)
+#define MINGW
+#endif
+
+#if (defined(__CYGWIN__) || defined(__CYGWIN32__)) && !defined(CYGWIN)
+#define CYGWIN
+#endif
+
+// __APPLE__ is the only predefined macro on MacOS X
+#if defined(__APPLE__)
+#define __DARWIN__
+#endif
+
+// 64bit OS
+#if defined(_M_IA64) || defined(_M_X64) || defined(_WIN64) || defined(_LP64) || defined(_ILP64) || defined(__LP64__) || defined(__ppc64__)
+#define __64BIT__
+#endif
+
+#if defined(_ILP64)
+#error "this specific 64bit architecture is not supported"
+#endif
+
+// debug mode
+#if defined(_DEBUG) && !defined(DEBUG)
+#define DEBUG
+#endif
+
+// debug function name
+#ifndef __NETBSD__
+#if __STDC_VERSION__ < 199901L
+#	if __GNUC__ >= 2
+#		define __func__ __FUNCTION__
+#	else
+#		define __func__ ""
+#	endif
+#endif
+#endif
+
+
+// disable attributed stuff on non-GNU
+#if !defined(__GNUC__) && !defined(MINGW)
+#  define  __attribute__(x)
+#endif
+
+
+//////////////////////////////////////////////////////////////////////////
+// typedefs to compensate type size change from 32bit to 64bit
+// MS implements LLP64 model, normal unix does LP64,
+// only Silicon Graphics/Cray goes ILP64 so don't care (and don't support)
+//////////////////////////////////////////////////////////////////////////
+
+#include <limits.h>
+// ILP64 isn't supported, so always 32 bits?
+#ifndef UINT_MAX
+#define UINT_MAX 0xffffffff
+#endif
+
+//////////////////////////////////////////////////////////////////////////
+// Integers with guaranteed _exact_ size.
+//////////////////////////////////////////////////////////////////////////
+
+#define SIZEOF_LONG 4
+#define SIZEOF_INT 4
+#define HAVE_INT_8_16_32
+
+typedef char				int8;
+typedef short				int16;
+typedef int					int32;
+
+typedef signed char			sint8;
+typedef signed short		sint16;
+typedef signed int			sint32;
+
+typedef unsigned char		uint8;
+typedef unsigned short		uint16;
+typedef unsigned int		uint32;
+
+#undef UINT8_MIN
+#undef UINT16_MIN
+#undef UINT32_MIN
+#define UINT8_MIN	((uint8) 0)
+#define UINT16_MIN	((uint16)0)
+#define UINT32_MIN	((uint32)0)
+
+#undef UINT8_MAX
+#undef UINT16_MAX
+#undef UINT32_MAX
+#define UINT8_MAX	((uint8) 0xFF)
+#define UINT16_MAX	((uint16)0xFFFF)
+#define UINT32_MAX	((uint32)0xFFFFFFFF)
+
+#undef SINT8_MIN
+#undef SINT16_MIN
+#undef SINT32_MIN
+#define SINT8_MIN	((sint8) 0x80)
+#define SINT16_MIN	((sint16)0x8000)
+#define SINT32_MIN	((sint32)0x80000000)
+
+#undef SINT8_MAX
+#undef SINT16_MAX
+#undef SINT32_MAX
+#define SINT8_MAX	((sint8) 0x7F)
+#define SINT16_MAX	((sint16)0x7FFF)
+#define SINT32_MAX	((sint32)0x7FFFFFFF)
+
+//////////////////////////////////////////////////////////////////////////
+// Integers with guaranteed _minimum_ size.
+// These could be larger than you expect,
+// they are designed for speed.
+//////////////////////////////////////////////////////////////////////////
+typedef          long int   ppint;
+typedef          long int   ppint8;
+typedef          long int   ppint16;
+typedef          long int   ppint32;
+
+typedef unsigned long int   ppuint;
+typedef unsigned long int   ppuint8;
+typedef unsigned long int   ppuint16;
+typedef unsigned long int   ppuint32;
+
+
+//////////////////////////////////////////////////////////////////////////
+// integer with exact processor width (and best speed)
+//////////////////////////////
+#include <stddef.h> // size_t
+
+#if defined(WIN32) && !defined(MINGW) // does not have a signed size_t
+//////////////////////////////
+#if defined(_WIN64)	// naive 64bit windows platform
+typedef __int64			ssize_t;
+#else
+typedef int				ssize_t;
+#endif
+//////////////////////////////
+#endif
+//////////////////////////////
+
+
+//////////////////////////////////////////////////////////////////////////
+// portable 64-bit integers
+//////////////////////////////////////////////////////////////////////////
+#if defined(_MSC_VER) || defined(__BORLANDC__)
+typedef __int64				int64;
+typedef signed __int64		sint64;
+typedef unsigned __int64	uint64;
+#define LLCONST(a)			(a##i64)
+#else
+typedef long long			int64;
+typedef signed long long	sint64;
+typedef unsigned long long	uint64;
+#define LLCONST(a)			(a##ll)
+#endif
+
+#ifndef INT64_MIN
+#define INT64_MIN  (LLCONST(-9223372036854775807)-1)
+#endif
+#ifndef INT64_MAX
+#define INT64_MAX  (LLCONST(9223372036854775807))
+#endif
+#ifndef UINT64_MAX
+#define UINT64_MAX (LLCONST(18446744073709551615u))
+#endif
+
+
+//////////////////////////////////////////////////////////////////////////
+// pointer sized integers
+//////////////////////////////////////////////////////////////////////////
+#ifdef __64BIT__
+typedef uint64 uintptr;
+typedef int64 intptr;
+#else
+typedef uint32 uintptr;
+typedef int32 intptr;
+#endif
+
+
+//////////////////////////////////////////////////////////////////////////
+// some redefine of function redefines for some Compilers
+//////////////////////////////////////////////////////////////////////////
+#if defined(_MSC_VER) || defined(__BORLANDC__)
+#define strcasecmp			stricmp
+#define strncasecmp			strnicmp
+#define strncmpi			strnicmp
+#define snprintf			_snprintf
+#if defined(_MSC_VER) && _MSC_VER < 1400
+#define vsnprintf			_vsnprintf
+#endif
+#else
+#define strcmpi				strcasecmp
+#define stricmp				strcasecmp
+#define strncmpi			strncasecmp
+#define strnicmp			strncasecmp
+#endif
+
+// keyword replacement in windows
+#ifdef _WIN32
+#define inline __inline
+#endif
+
+/////////////////////////////
+// for those still not building c++
+#ifndef __cplusplus
+//////////////////////////////
+
+// boolean types for C
+typedef char bool;
+#define false	(1==0)
+#define true	(1==1)
+
+//////////////////////////////
+#endif // not cplusplus
+//////////////////////////////
+
+//////////////////////////////////////////////////////////////////////////
+// macro tools
+
+#ifdef swap // just to be sure
+#undef swap
+#endif
+// hmm only ints?
+//#define swap(a,b) { int temp=a; a=b; b=temp;} 
+// if using macros then something that is type independent
+//#define swap(a,b) ((a == b) || ((a ^= b), (b ^= a), (a ^= b)))
+// Avoid "value computed is not used" warning and generates the same assembly code
+#define swap(a,b) if (a != b) ((a ^= b), (b ^= a), (a ^= b))
+
+#ifndef max
+#define max(a,b) (((a) > (b)) ? (a) : (b))
+#endif
+
+#ifndef min
+#define min(a,b) (((a) < (b)) ? (a) : (b))
+#endif
+
+//////////////////////////////////////////////////////////////////////////
+// should not happen
+#ifndef NULL
+#define NULL (void *)0
+#endif
+
+//////////////////////////////////////////////////////////////////////////
+// number of bits in a byte
+#ifndef NBBY
+#define	NBBY 8
+#endif
+
+//////////////////////////////////////////////////////////////////////////
+// path separator
+
+#if defined(WIN32)
+#define PATHSEP '\\'
+#elif defined(__APPLE__)
+#define PATHSEP ':'
+#else
+#define PATHSEP '/'
+#endif
+
+//////////////////////////////////////////////////////////////////////////
+// Assert
+
+#if ! defined(Assert)
+#if defined(RELEASE)
+#define Assert(EX)
+#else
+// extern "C" {
+#include <assert.h>
+// }
+#if !defined(DEFCPP) && defined(WIN32) && !defined(MINGW)
+#include <crtdbg.h>
+#endif
+#define Assert(EX) assert(EX)
+#endif
+#endif /* ! defined(Assert) */
+
+//////////////////////////////////////////////////////////////////////////
+// Has to be unsigned to avoid problems in some systems
+// Problems arise when these functions expect an argument in the range [0,256[ and are fed a signed char.
+#include <ctype.h>
+#define ISALNUM(c) (isalnum((unsigned char)(c)))
+#define ISALPHA(c) (isalpha((unsigned char)(c)))
+#define ISCNTRL(c) (iscntrl((unsigned char)(c)))
+#define ISDIGIT(c) (isdigit((unsigned char)(c)))
+#define ISGRAPH(c) (isgraph((unsigned char)(c)))
+#define ISLOWER(c) (islower((unsigned char)(c)))
+#define ISPRINT(c) (isprint((unsigned char)(c)))
+#define ISPUNCT(c) (ispunct((unsigned char)(c)))
+#define ISSPACE(c) (isspace((unsigned char)(c)))
+#define ISUPPER(c) (isupper((unsigned char)(c)))
+#define ISXDIGIT(c) (isxdigit((unsigned char)(c)))
+#define TOASCII(c) (toascii((unsigned char)(c)))
+#define TOLOWER(c) (tolower((unsigned char)(c)))
+#define TOUPPER(c) (toupper((unsigned char)(c)))
+
+//////////////////////////////////////////////////////////////////////////
+// length of a static array
+#define ARRAYLENGTH(A) ( sizeof(A)/sizeof((A)[0]) )
+
+//////////////////////////////////////////////////////////////////////////
+// Make sure va_copy exists
+#include <stdarg.h> // va_list, va_copy(?)
+#if !defined(va_copy)
+#if defined(__va_copy)
+#define va_copy __va_copy
+#else
+#define va_copy(dst, src) ((void) memcpy(&(dst), &(src), sizeof(va_list)))
+#endif
+#endif
+
+#endif /* _CBASETYPES_H_ */
diff --git a/src/common/malloc.c b/src/common/malloc.c
index 8d68bee..ecbb8cb 100644
--- a/src/common/malloc.c
+++ b/src/common/malloc.c
@@ -66,3 +66,12 @@ char *aStrdup_ (const char *p, const char *file, int line, const char *func)
 
     return ret;
 }
+
+void aFree_(void *p, const char *file __attribute__ ((unused)), int line __attribute__ ((unused)), const char *func __attribute__ ((unused)))
+{
+    // ShowMessage("%s:%d: in func %s: aFree %p\n",file,line,func,p);
+    if (p)
+        FREE(p, file, line, func);
+
+    p = NULL;
+}
\ No newline at end of file
diff --git a/src/common/malloc.h b/src/common/malloc.h
index 5fc8cbe..d13603b 100644
--- a/src/common/malloc.h
+++ b/src/common/malloc.h
@@ -15,6 +15,15 @@ void *aMalloc_ (size_t, const char *, int, const char *);
 void *aCalloc_ (size_t, size_t, const char *, int, const char *);
 void *aRealloc_ (void *, size_t, const char *, int, const char *);
 char *aStrdup_ (const char *, const char *, int, const char *);
+void aFree_(void *p, const char *file, int line, const char *func);
+
+#define MALLOC(n,file,line,func)    malloc(n)
+#define MALLOCA(n,file,line,func)   malloc(n)
+#define CALLOC(m,n,file,line,func)  calloc((m),(n))
+#define CALLOCA(m,n,file,line,func) calloc((m),(n))
+#define REALLOC(p,n,file,line,func) realloc((p),(n))
+#define STRDUP(p,file,line,func)    strdup(p)
+#define FREE(p,file,line,func)      free(p)
 
 #define aMalloc(n) aMalloc_(n,ALC_MARK)
 #define aMallocA(n) aMalloc_(n,ALC_MARK)
diff --git a/src/common/mmo.h b/src/common/mmo.h
index 9c63501..891bbe1 100644
--- a/src/common/mmo.h
+++ b/src/common/mmo.h
@@ -65,6 +65,8 @@
 
 #define CHAR_CONF_NAME  "conf/char_athena.conf"
 
+#define MAP_NAME_LENGTH 24
+
 struct item
 {
     int  id;
diff --git a/src/common/showmsg.c b/src/common/showmsg.c
new file mode 100644
index 0000000..c50716b
--- /dev/null
+++ b/src/common/showmsg.c
@@ -0,0 +1,855 @@
+// Copyright (c) Athena Dev Teams - Licensed under GNU GPL
+// For more information, see LICENCE in the main folder
+
+#include "../common/cbasetypes.h"
+#include "../common/strlib.h" // StringBuf
+#include "showmsg.h"
+
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+#include <time.h>
+#include <stdlib.h> // atexit
+
+#ifdef WIN32
+	#define WIN32_LEAN_AND_MEAN
+	#include <windows.h>
+
+	#ifdef DEBUGLOGMAP
+		#define DEBUGLOGPATH "log\\map-server.log"
+	#else
+		#ifdef DEBUGLOGCHAR
+			#define DEBUGLOGPATH "log\\char-server.log"
+		#else
+			#ifdef DEBUGLOGLOGIN
+				#define DEBUGLOGPATH "log\\login-server.log"
+			#endif
+		#endif
+	#endif
+#else
+	#include <unistd.h>
+
+	#ifdef DEBUGLOGMAP
+		#define DEBUGLOGPATH "log/map-server.log"
+	#else
+		#ifdef DEBUGLOGCHAR
+			#define DEBUGLOGPATH "log/char-server.log"
+		#else
+			#ifdef DEBUGLOGLOGIN
+				#define DEBUGLOGPATH "log/login-server.log"
+			#endif
+		#endif
+	#endif
+#endif
+
+///////////////////////////////////////////////////////////////////////////////
+/// behavioral parameter.
+/// when redirecting output:
+/// if true prints escape sequences
+/// if false removes the escape sequences
+int stdout_with_ansisequence = 0;
+
+int msg_silent = 0; //Specifies how silent the console is.
+
+///////////////////////////////////////////////////////////////////////////////
+/// static/dynamic buffer for the messages
+
+#define SBUF_SIZE 2048 // never put less that what's required for the debug message
+
+#define NEWBUF(buf)				\
+	struct {					\
+		char s_[SBUF_SIZE];		\
+		StringBuf *d_;			\
+		char *v_;				\
+		int l_;					\
+	} buf ={"",NULL,NULL,0};	\
+//define NEWBUF
+
+#define BUFVPRINTF(buf,fmt,args)						\
+	buf.l_ = vsnprintf(buf.s_, SBUF_SIZE, fmt, args);	\
+	if( buf.l_ >= 0 && buf.l_ < SBUF_SIZE )				\
+	{/* static buffer */								\
+		buf.v_ = buf.s_;								\
+	}													\
+	else												\
+	{/* dynamic buffer */								\
+		buf.d_ = StringBuf_Malloc();					\
+		buf.l_ = StringBuf_Vprintf(buf.d_, fmt, args);	\
+		buf.v_ = StringBuf_Value(buf.d_);				\
+		ShowDebug("showmsg: dynamic buffer used, increase the static buffer size to %d or more.\n", buf.l_+1);\
+	}													\
+//define BUFVPRINTF
+
+#define BUFVAL(buf) buf.v_
+#define BUFLEN(buf) buf.l_
+
+#define FREEBUF(buf)			\
+	if( buf.d_ )				\
+	{							\
+		StringBuf_Free(buf.d_);	\
+		buf.d_ = NULL;			\
+	}							\
+	buf.v_ = NULL;				\
+//define FREEBUF
+
+///////////////////////////////////////////////////////////////////////////////
+#ifdef _WIN32
+// XXX adapted from eApp (comments are left untouched) [flaviojs]
+
+///////////////////////////////////////////////////////////////////////////////
+//  ansi compatible printf with control sequence parser for windows
+//  fast hack, handle with care, not everything implemented
+//
+// \033[#;...;#m - Set Graphics Rendition (SGR) 
+//
+//  printf("\x1b[1;31;40m");	// Bright red on black
+//  printf("\x1b[3;33;45m");	// Blinking yellow on magenta (blink not implemented)
+//  printf("\x1b[1;30;47m");	// Bright black (grey) on dim white
+//
+//  Style           Foreground      Background
+//  1st Digit       2nd Digit       3rd Digit		RGB
+//  0 - Reset       30 - Black      40 - Black		000
+//  1 - FG Bright   31 - Red        41 - Red		100
+//  2 - Unknown     32 - Green      42 - Green		010
+//  3 - Blink       33 - Yellow     43 - Yellow		110
+//  4 - Underline   34 - Blue       44 - Blue		001
+//  5 - BG Bright   35 - Magenta    45 - Magenta	101
+//  6 - Unknown     36 - Cyan       46 - Cyan		011
+//  7 - Reverse     37 - White      47 - White		111
+//  8 - Concealed (invisible)
+//
+// \033[#A - Cursor Up (CUU)
+//    Moves the cursor up by the specified number of lines without changing columns. 
+//    If the cursor is already on the top line, this sequence is ignored. \e[A is equivalent to \e[1A.
+//
+// \033[#B - Cursor Down (CUD)
+//    Moves the cursor down by the specified number of lines without changing columns. 
+//    If the cursor is already on the bottom line, this sequence is ignored. \e[B is equivalent to \e[1B.
+//
+// \033[#C - Cursor Forward (CUF)
+//    Moves the cursor forward by the specified number of columns without changing lines. 
+//    If the cursor is already in the rightmost column, this sequence is ignored. \e[C is equivalent to \e[1C.
+//
+// \033[#D - Cursor Backward (CUB)
+//    Moves the cursor back by the specified number of columns without changing lines. 
+//    If the cursor is already in the leftmost column, this sequence is ignored. \e[D is equivalent to \e[1D.
+//
+// \033[#E - Cursor Next Line (CNL)
+//    Moves the cursor down the indicated # of rows, to column 1. \e[E is equivalent to \e[1E.
+//
+// \033[#F - Cursor Preceding Line (CPL)
+//    Moves the cursor up the indicated # of rows, to column 1. \e[F is equivalent to \e[1F.
+//
+// \033[#G - Cursor Horizontal Absolute (CHA)
+//    Moves the cursor to indicated column in current row. \e[G is equivalent to \e[1G.
+//
+// \033[#;#H - Cursor Position (CUP)
+//    Moves the cursor to the specified position. The first # specifies the line number, 
+//    the second # specifies the column. If you do not specify a position, the cursor moves to the home position: 
+//    the upper-left corner of the screen (line 1, column 1).
+//
+// \033[#;#f - Horizontal & Vertical Position
+//    (same as \033[#;#H)
+//
+// \033[s - Save Cursor Position (SCP)
+//    The current cursor position is saved. 
+//
+// \033[u - Restore cursor position (RCP)
+//    Restores the cursor position saved with the (SCP) sequence \033[s.
+//    (addition, restore to 0,0 if nothinh was saved before)
+//
+
+// \033[#J - Erase Display (ED)
+//    Clears the screen and moves to the home position
+//    \033[0J - Clears the screen from cursor to end of display. The cursor position is unchanged. (default)
+//    \033[1J - Clears the screen from start to cursor. The cursor position is unchanged.
+//    \033[2J - Clears the screen and moves the cursor to the home position (line 1, column 1).
+//
+// \033[#K - Erase Line (EL)
+//    Clears the current line from the cursor position
+//    \033[0K - Clears all characters from the cursor position to the end of the line (including the character at the cursor position). The cursor position is unchanged. (default)
+//    \033[1K - Clears all characters from start of line to the cursor position. (including the character at the cursor position). The cursor position is unchanged.
+//    \033[2K - Clears all characters of the whole line. The cursor position is unchanged.
+
+
+/*
+not implemented
+
+\033[#L
+IL: Insert Lines: The cursor line and all lines below it move down # lines, leaving blank space. The cursor position is unchanged. The bottommost # lines are lost. \e[L is equivalent to \e[1L.
+\033[#M
+DL: Delete Line: The block of # lines at and below the cursor are deleted; all lines below them move up # lines to fill in the gap, leaving # blank lines at the bottom of the screen. The cursor position is unchanged. \e[M is equivalent to \e[1M.
+\033[#\@
+ICH: Insert CHaracter: The cursor character and all characters to the right of it move right # columns, leaving behind blank space. The cursor position is unchanged. The rightmost # characters on the line are lost. \e[\@ is equivalent to \e[1\@.
+\033[#P
+DCH: Delete CHaracter: The block of # characters at and to the right of the cursor are deleted; all characters to the right of it move left # columns, leaving behind blank space. The cursor position is unchanged. \e[P is equivalent to \e[1P.
+
+Escape sequences for Select Character Set
+*/
+
+#define is_console(handle) (FILE_TYPE_CHAR==GetFileType(handle))
+
+///////////////////////////////////////////////////////////////////////////////
+int	VFPRINTF(HANDLE handle, const char *fmt, va_list argptr)
+{
+	/////////////////////////////////////////////////////////////////
+	/* XXX Two streams are being used. Disabled to avoid inconsistency [flaviojs]		
+	static COORD saveposition = {0,0};
+	*/
+
+	/////////////////////////////////////////////////////////////////
+	DWORD written;
+	char *p, *q;
+	NEWBUF(tempbuf); // temporary buffer
+
+	if(!fmt || !*fmt)
+		return 0;
+
+	// Print everything to the buffer
+	BUFVPRINTF(tempbuf,fmt,argptr);
+
+	if( !is_console(handle) && stdout_with_ansisequence )
+	{
+		WriteFile(handle, BUFVAL(tempbuf), BUFLEN(tempbuf), &written, 0);
+		return 0;
+	}
+
+	// start with processing
+	p = BUFVAL(tempbuf);
+	while ((q = strchr(p, 0x1b)) != NULL)
+	{	// find the escape character
+		if( 0==WriteConsole(handle, p, (DWORD)(q-p), &written, 0) ) // write up to the escape
+			WriteFile(handle, p, (DWORD)(q-p), &written, 0);
+
+		if( q[1]!='[' )
+		{	// write the escape char (whatever purpose it has) 
+			if(0==WriteConsole(handle, q, 1, &written, 0) )
+				WriteFile(handle,q, 1, &written, 0);
+			p=q+1;	//and start searching again
+		}
+		else
+		{	// from here, we will skip the '\033['
+			// we break at the first unprocessible position
+			// assuming regular text is starting there
+			uint8 numbers[16], numpoint=0;
+			CONSOLE_SCREEN_BUFFER_INFO info;
+
+			// initialize
+			GetConsoleScreenBufferInfo(handle, &info);
+			memset(numbers,0,sizeof(numbers));
+
+			// skip escape and bracket
+			q=q+2;	
+			for(;;)
+			{
+				if( ISDIGIT(*q) ) 
+				{	// add number to number array, only accept 2digits, shift out the rest
+					// so // \033[123456789m will become \033[89m
+					numbers[numpoint] = (numbers[numpoint]<<4) | (*q-'0');
+					++q;
+					// and next character
+					continue;
+				}
+				else if( *q == ';' )
+				{	// delimiter
+					if(numpoint<sizeof(numbers)/sizeof(*numbers))
+					{	// go to next array position
+						numpoint++;
+					}
+					else
+					{	// array is full, so we 'forget' the first value
+						memmove(numbers,numbers+1,sizeof(numbers)/sizeof(*numbers)-1);
+						numbers[sizeof(numbers)/sizeof(*numbers)-1]=0;
+					}
+					++q;
+					// and next number
+					continue;
+				}
+				else if( *q == 'm' )
+				{	// \033[#;...;#m - Set Graphics Rendition (SGR)
+					uint8 i;
+					for(i=0; i<= numpoint; ++i)
+					{
+						if( 0x00 == (0xF0 & numbers[i]) )
+						{	// upper nibble 0
+							if( 0 == numbers[i] )
+							{	// reset
+								info.wAttributes = FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE;
+							}
+							else if( 1==numbers[i] )
+							{	// set foreground intensity
+								info.wAttributes |= FOREGROUND_INTENSITY;
+							}
+							else if( 5==numbers[i] )
+							{	// set background intensity
+								info.wAttributes |= BACKGROUND_INTENSITY;
+							}
+							else if( 7==numbers[i] )
+							{	// reverse colors (just xor them)
+								info.wAttributes ^= FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE |
+													BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE;
+							}
+							//case '2': // not existing
+							//case '3':	// blinking (not implemented)
+							//case '4':	// unterline (not implemented)
+							//case '6': // not existing
+							//case '8': // concealed (not implemented)
+							//case '9': // not existing
+						}
+						else if( 0x20 == (0xF0 & numbers[i]) )
+						{	// off
+
+							if( 1==numbers[i] )
+							{	// set foreground intensity off
+								info.wAttributes &= ~FOREGROUND_INTENSITY;
+							}
+							else if( 5==numbers[i] )
+							{	// set background intensity off
+								info.wAttributes &= ~BACKGROUND_INTENSITY;
+							}
+							else if( 7==numbers[i] )
+							{	// reverse colors (just xor them)
+								info.wAttributes ^= FOREGROUND_RED | FOREGROUND_GREEN | FOREGROUND_BLUE |
+													BACKGROUND_RED | BACKGROUND_GREEN | BACKGROUND_BLUE;
+							}
+						}
+						else if( 0x30 == (0xF0 & numbers[i]) )
+						{	// foreground
+							uint8 num = numbers[i]&0x0F;
+							if(num==9) info.wAttributes |= FOREGROUND_INTENSITY;
+							if(num>7) num=7;	// set white for 37, 38 and 39
+							info.wAttributes &= ~(FOREGROUND_RED|FOREGROUND_GREEN|FOREGROUND_BLUE);
+							if( (num & 0x01)>0 ) // lowest bit set = red
+								info.wAttributes |= FOREGROUND_RED;
+							if( (num & 0x02)>0 ) // second bit set = green
+								info.wAttributes |= FOREGROUND_GREEN;
+							if( (num & 0x04)>0 ) // third bit set = blue
+								info.wAttributes |= FOREGROUND_BLUE;
+						}
+						else if( 0x40 == (0xF0 & numbers[i]) )
+						{	// background
+							uint8 num = numbers[i]&0x0F;
+							if(num==9) info.wAttributes |= BACKGROUND_INTENSITY;
+							if(num>7) num=7;	// set white for 47, 48 and 49
+							info.wAttributes &= ~(BACKGROUND_RED|BACKGROUND_GREEN|BACKGROUND_BLUE);
+							if( (num & 0x01)>0 ) // lowest bit set = red
+								info.wAttributes |= BACKGROUND_RED;
+							if( (num & 0x02)>0 ) // second bit set = green
+								info.wAttributes |= BACKGROUND_GREEN;
+							if( (num & 0x04)>0 ) // third bit set = blue
+								info.wAttributes |= BACKGROUND_BLUE;
+						}
+					}
+					// set the attributes
+					SetConsoleTextAttribute(handle, info.wAttributes);
+				}
+				else if( *q=='J' )
+				{	// \033[#J - Erase Display (ED)
+					//    \033[0J - Clears the screen from cursor to end of display. The cursor position is unchanged.
+					//    \033[1J - Clears the screen from start to cursor. The cursor position is unchanged.
+					//    \033[2J - Clears the screen and moves the cursor to the home position (line 1, column 1).
+					uint8 num = (numbers[numpoint]>>4)*10+(numbers[numpoint]&0x0F);
+					int cnt;
+					DWORD tmp;
+					COORD origin = {0,0};
+					if(num==1)
+					{	// chars from start up to and including cursor
+						cnt = info.dwSize.X * info.dwCursorPosition.Y + info.dwCursorPosition.X + 1;	
+					}
+					else if(num==2)
+					{	// Number of chars on screen.
+						cnt = info.dwSize.X * info.dwSize.Y;	
+						SetConsoleCursorPosition(handle, origin); 
+					}
+					else// 0 and default
+					{	// number of chars from cursor to end
+						origin = info.dwCursorPosition;
+						cnt = info.dwSize.X * (info.dwSize.Y - info.dwCursorPosition.Y) - info.dwCursorPosition.X; 
+					}				
+					FillConsoleOutputAttribute(handle, info.wAttributes, cnt, origin, &tmp);
+					FillConsoleOutputCharacter(handle, ' ',              cnt, origin, &tmp);
+				}
+				else if( *q=='K' )
+				{	// \033[K  : clear line from actual position to end of the line
+					//    \033[0K - Clears all characters from the cursor position to the end of the line.
+					//    \033[1K - Clears all characters from start of line to the cursor position.
+					//    \033[2K - Clears all characters of the whole line.
+
+					uint8 num = (numbers[numpoint]>>4)*10+(numbers[numpoint]&0x0F);
+					COORD origin = {0,info.dwCursorPosition.Y}; //warning C4204
+					SHORT cnt;
+					DWORD tmp;
+					if(num==1)
+					{	
+						cnt = info.dwCursorPosition.X + 1;
+					}
+					else if(num==2)
+					{	
+						cnt = info.dwSize.X;
+					}
+					else// 0 and default
+					{
+						origin = info.dwCursorPosition;
+						cnt = info.dwSize.X - info.dwCursorPosition.X; // how many spaces until line is full
+					}
+					FillConsoleOutputAttribute(handle, info.wAttributes, cnt, origin, &tmp);
+					FillConsoleOutputCharacter(handle, ' ',              cnt, origin, &tmp);
+				}
+				else if( *q == 'H' || *q == 'f' )
+				{	// \033[#;#H - Cursor Position (CUP)
+					// \033[#;#f - Horizontal & Vertical Position
+					// The first # specifies the line number, the second # specifies the column. 
+					// The default for both is 1
+					info.dwCursorPosition.X = (numbers[numpoint])?(numbers[numpoint]>>4)*10+((numbers[numpoint]&0x0F)-1):0;
+					info.dwCursorPosition.Y = (numpoint && numbers[numpoint-1])?(numbers[numpoint-1]>>4)*10+((numbers[numpoint-1]&0x0F)-1):0;
+
+					if( info.dwCursorPosition.X >= info.dwSize.X ) info.dwCursorPosition.Y = info.dwSize.X-1;
+					if( info.dwCursorPosition.Y >= info.dwSize.Y ) info.dwCursorPosition.Y = info.dwSize.Y-1;
+					SetConsoleCursorPosition(handle, info.dwCursorPosition);
+				}
+				else if( *q=='s' )
+				{	// \033[s - Save Cursor Position (SCP)
+					/* XXX Two streams are being used. Disabled to avoid inconsistency [flaviojs]
+					CONSOLE_SCREEN_BUFFER_INFO info;
+					GetConsoleScreenBufferInfo(handle, &info);
+					saveposition = info.dwCursorPosition;
+					*/
+				}
+				else if( *q=='u' )
+				{	// \033[u - Restore cursor position (RCP)
+					/* XXX Two streams are being used. Disabled to avoid inconsistency [flaviojs]
+					SetConsoleCursorPosition(handle, saveposition);
+					*/
+				}
+				else if( *q == 'A' )
+				{	// \033[#A - Cursor Up (CUU)
+					// Moves the cursor UP # number of lines
+					info.dwCursorPosition.Y -= (numbers[numpoint])?(numbers[numpoint]>>4)*10+(numbers[numpoint]&0x0F):1;
+
+					if( info.dwCursorPosition.Y < 0 )
+						info.dwCursorPosition.Y = 0;
+					SetConsoleCursorPosition(handle, info.dwCursorPosition);
+				}
+				else if( *q == 'B' )
+				{	// \033[#B - Cursor Down (CUD)
+					// Moves the cursor DOWN # number of lines
+					info.dwCursorPosition.Y += (numbers[numpoint])?(numbers[numpoint]>>4)*10+(numbers[numpoint]&0x0F):1;
+
+					if( info.dwCursorPosition.Y >= info.dwSize.Y )
+						info.dwCursorPosition.Y = info.dwSize.Y-1;
+					SetConsoleCursorPosition(handle, info.dwCursorPosition);
+				}
+				else if( *q == 'C' )
+				{	// \033[#C - Cursor Forward (CUF)
+					// Moves the cursor RIGHT # number of columns
+					info.dwCursorPosition.X += (numbers[numpoint])?(numbers[numpoint]>>4)*10+(numbers[numpoint]&0x0F):1;
+
+					if( info.dwCursorPosition.X >= info.dwSize.X )
+						info.dwCursorPosition.X = info.dwSize.X-1;
+					SetConsoleCursorPosition(handle, info.dwCursorPosition);
+				}
+				else if( *q == 'D' )
+				{	// \033[#D - Cursor Backward (CUB)
+					// Moves the cursor LEFT # number of columns
+					info.dwCursorPosition.X -= (numbers[numpoint])?(numbers[numpoint]>>4)*10+(numbers[numpoint]&0x0F):1;
+
+					if( info.dwCursorPosition.X < 0 )
+						info.dwCursorPosition.X = 0;
+					SetConsoleCursorPosition(handle, info.dwCursorPosition);
+				}
+				else if( *q == 'E' )
+				{	// \033[#E - Cursor Next Line (CNL)
+					// Moves the cursor down the indicated # of rows, to column 1
+					info.dwCursorPosition.Y += (numbers[numpoint])?(numbers[numpoint]>>4)*10+(numbers[numpoint]&0x0F):1;
+					info.dwCursorPosition.X = 0;
+
+					if( info.dwCursorPosition.Y >= info.dwSize.Y )
+						info.dwCursorPosition.Y = info.dwSize.Y-1;
+					SetConsoleCursorPosition(handle, info.dwCursorPosition);
+				}
+				else if( *q == 'F' )
+				{	// \033[#F - Cursor Preceding Line (CPL)
+					// Moves the cursor up the indicated # of rows, to column 1.
+					info.dwCursorPosition.Y -= (numbers[numpoint])?(numbers[numpoint]>>4)*10+(numbers[numpoint]&0x0F):1;
+					info.dwCursorPosition.X = 0;
+
+					if( info.dwCursorPosition.Y < 0 )
+						info.dwCursorPosition.Y = 0;
+					SetConsoleCursorPosition(handle, info.dwCursorPosition);
+				}
+				else if( *q == 'G' )
+				{	// \033[#G - Cursor Horizontal Absolute (CHA)
+					// Moves the cursor to indicated column in current row.
+					info.dwCursorPosition.X = (numbers[numpoint])?(numbers[numpoint]>>4)*10+((numbers[numpoint]&0x0F)-1):0;
+
+					if( info.dwCursorPosition.X >= info.dwSize.X )
+						info.dwCursorPosition.X = info.dwSize.X-1;
+					SetConsoleCursorPosition(handle, info.dwCursorPosition);
+				}
+				else if( *q == 'L' || *q == 'M' || *q == '@' || *q == 'P')
+				{	// not implemented, just skip
+				}
+				else
+				{	// no number nor valid sequencer
+					// something is fishy, we break and give the current char free
+					--q;
+				}
+				// skip the sequencer and search again
+				p = q+1; 
+				break;
+			}// end while
+		}
+	}
+	if (*p)	// write the rest of the buffer
+		if( 0==WriteConsole(handle, p, (DWORD)strlen(p), &written, 0) )
+			WriteFile(handle, p, (DWORD)strlen(p), &written, 0);
+	FREEBUF(tempbuf);
+	return 0;
+}
+
+int	FPRINTF(HANDLE handle, const char *fmt, ...)
+{	
+	int ret;
+	va_list argptr;
+	va_start(argptr, fmt);
+	ret = VFPRINTF(handle,fmt,argptr);
+	va_end(argptr);
+	return ret;
+}
+
+#define FFLUSH(handle)
+
+#define STDOUT GetStdHandle(STD_OUTPUT_HANDLE)
+#define STDERR GetStdHandle(STD_ERROR_HANDLE)
+
+#else // not _WIN32
+
+
+#define is_console(file) (0!=isatty(fileno(file)))
+
+//vprintf_without_ansiformats
+int	VFPRINTF(FILE *file, const char *fmt, va_list argptr)
+{
+	char *p, *q;
+	NEWBUF(tempbuf); // temporary buffer
+
+	if(!fmt || !*fmt)
+		return 0;
+
+	if( is_console(file) || stdout_with_ansisequence )
+	{
+		vfprintf(file, fmt, argptr);
+		return 0;
+	}
+
+	// Print everything to the buffer
+	BUFVPRINTF(tempbuf,fmt,argptr);
+
+	// start with processing
+	p = BUFVAL(tempbuf);
+	while ((q = strchr(p, 0x1b)) != NULL)
+	{	// find the escape character
+		fprintf(file, "%.*s", (int)(q-p), p); // write up to the escape
+		if( q[1]!='[' )
+		{	// write the escape char (whatever purpose it has) 
+			fprintf(file, "%.*s", 1, q);
+			p=q+1;	//and start searching again
+		}
+		else
+		{	// from here, we will skip the '\033['
+			// we break at the first unprocessible position
+			// assuming regular text is starting there
+
+			// skip escape and bracket
+			q=q+2;	
+			while(1)
+			{
+				if( ISDIGIT(*q) ) 
+				{					
+					++q;
+					// and next character
+					continue;
+				}
+				else if( *q == ';' )
+				{	// delimiter
+					++q;
+					// and next number
+					continue;
+				}
+				else if( *q == 'm' )
+				{	// \033[#;...;#m - Set Graphics Rendition (SGR)
+					// set the attributes
+				}
+				else if( *q=='J' )
+				{	// \033[#J - Erase Display (ED)
+				}
+				else if( *q=='K' )
+				{	// \033[K  : clear line from actual position to end of the line
+				}
+				else if( *q == 'H' || *q == 'f' )
+				{	// \033[#;#H - Cursor Position (CUP)
+					// \033[#;#f - Horizontal & Vertical Position
+				}
+				else if( *q=='s' )
+				{	// \033[s - Save Cursor Position (SCP)
+				}
+				else if( *q=='u' )
+				{	// \033[u - Restore cursor position (RCP)
+				}
+				else if( *q == 'A' )
+				{	// \033[#A - Cursor Up (CUU)
+					// Moves the cursor UP # number of lines
+				}
+				else if( *q == 'B' )
+				{	// \033[#B - Cursor Down (CUD)
+					// Moves the cursor DOWN # number of lines
+				}
+				else if( *q == 'C' )
+				{	// \033[#C - Cursor Forward (CUF)
+					// Moves the cursor RIGHT # number of columns
+				}
+				else if( *q == 'D' )
+				{	// \033[#D - Cursor Backward (CUB)
+					// Moves the cursor LEFT # number of columns
+				}
+				else if( *q == 'E' )
+				{	// \033[#E - Cursor Next Line (CNL)
+					// Moves the cursor down the indicated # of rows, to column 1
+				}
+				else if( *q == 'F' )
+				{	// \033[#F - Cursor Preceding Line (CPL)
+					// Moves the cursor up the indicated # of rows, to column 1.
+				}
+				else if( *q == 'G' )
+				{	// \033[#G - Cursor Horizontal Absolute (CHA)
+					// Moves the cursor to indicated column in current row.
+				}
+				else if( *q == 'L' || *q == 'M' || *q == '@' || *q == 'P')
+				{	// not implemented, just skip
+				}
+				else
+				{	// no number nor valid sequencer
+					// something is fishy, we break and give the current char free
+					--q;
+				}
+				// skip the sequencer and search again
+				p = q+1; 
+				break;
+			}// end while
+		}
+	}
+	if (*p)	// write the rest of the buffer
+		fprintf(file, "%s", p);
+	FREEBUF(tempbuf);
+	return 0;
+}
+int	FPRINTF(FILE *file, const char *fmt, ...)
+{	
+	int ret;
+	va_list argptr;
+	va_start(argptr, fmt);
+	ret = VFPRINTF(file,fmt,argptr);
+	va_end(argptr);
+	return ret;
+}
+
+#define FFLUSH fflush
+
+#define STDOUT stdout
+#define STDERR stderr
+
+#endif// not _WIN32
+
+
+
+
+
+
+
+
+
+
+char timestamp_format[20] = ""; //For displaying Timestamps
+
+int _vShowMessage(enum msg_type flag, const char *string, va_list ap)
+{
+	char prefix[100];
+#if defined(DEBUGLOGMAP) || defined(DEBUGLOGCHAR) || defined(DEBUGLOGLOGIN)
+	FILE *fp;
+#endif
+	
+	if (!string || *string == '\0') {
+		ShowError("Empty string passed to _vShowMessage().\n");
+		return 1;
+	}
+	if(
+	    (flag == MSG_INFORMATION && msg_silent&1) ||
+	    (flag == MSG_STATUS && msg_silent&2) ||
+	    (flag == MSG_NOTICE && msg_silent&4) ||
+	    (flag == MSG_WARNING && msg_silent&8) ||
+	    (flag == MSG_ERROR && msg_silent&16) ||
+	    (flag == MSG_SQL && msg_silent&16) ||
+	    (flag == MSG_DEBUG && msg_silent&32)
+	)
+		return 0; //Do not print it.
+
+	if (timestamp_format[0] && flag != MSG_NONE)
+	{	//Display time format. [Skotlex]
+		time_t t = time(NULL);
+		strftime(prefix, 80, timestamp_format, localtime(&t));
+	} else prefix[0]='\0';
+
+	switch (flag) {
+		case MSG_NONE: // direct printf replacement
+			break;
+		case MSG_STATUS: //Bright Green (To inform about good things)
+			strcat(prefix,CL_GREEN"[Status]"CL_RESET":");
+			break;
+		case MSG_SQL: //Bright Violet (For dumping out anything related with SQL) <- Actually, this is mostly used for SQL errors with the database, as successes can as well just be anything else... [Skotlex]
+			strcat(prefix,CL_MAGENTA"[SQL]"CL_RESET":");
+			break;
+		case MSG_INFORMATION: //Bright White (Variable information)
+			strcat(prefix,CL_WHITE"[Info]"CL_RESET":");
+			break;
+		case MSG_NOTICE: //Bright White (Less than a warning)
+			strcat(prefix,CL_WHITE"[Notice]"CL_RESET":");
+			break;
+		case MSG_WARNING: //Bright Yellow
+			strcat(prefix,CL_YELLOW"[Warning]"CL_RESET":");
+			break;
+		case MSG_DEBUG: //Bright Cyan, important stuff!
+			strcat(prefix,CL_CYAN"[Debug]"CL_RESET":");
+			break;
+		case MSG_ERROR: //Bright Red  (Regular errors)
+			strcat(prefix,CL_RED"[Error]"CL_RESET":");
+			break;
+		case MSG_FATALERROR: //Bright Red (Fatal errors, abort(); if possible)
+			strcat(prefix,CL_RED"[Fatal Error]"CL_RESET":");
+			break;
+		default:
+			ShowError("In function _vShowMessage() -> Invalid flag passed.\n");
+			return 1;
+	}
+
+	if (flag == MSG_ERROR || flag == MSG_FATALERROR || flag == MSG_SQL)
+	{	//Send Errors to StdErr [Skotlex]
+		FPRINTF(STDERR, "%s ", prefix);
+		VFPRINTF(STDERR, string, ap);
+		FFLUSH(STDERR);
+	} else {
+		if (flag != MSG_NONE)
+			FPRINTF(STDOUT, "%s ", prefix);
+		VFPRINTF(STDOUT, string, ap);
+		FFLUSH(STDOUT);
+	}
+
+#if defined(DEBUGLOGMAP) || defined(DEBUGLOGCHAR) || defined(DEBUGLOGLOGIN)
+	if(strlen(DEBUGLOGPATH) > 0) {
+		fp=fopen(DEBUGLOGPATH,"a");
+		if (fp == NULL)	{
+			FPRINTF(STDERR, CL_RED"[ERROR]"CL_RESET": Could not open '"CL_WHITE"%s"CL_RESET"', access denied.\n", DEBUGLOGPATH);
+			FFLUSH(STDERR);
+		} else {
+			fprintf(fp,"%s ", prefix);
+			vfprintf(fp,string,ap);
+			fclose(fp);
+		}
+	} else {
+		FPRINTF(STDERR, CL_RED"[ERROR]"CL_RESET": DEBUGLOGPATH not defined!\n");
+		FFLUSH(STDERR);
+	}
+#endif
+
+	va_end(ap);
+	return 0;
+}
+
+void ClearScreen(void)
+{
+#ifndef _WIN32
+	ShowMessage(CL_CLS);	// to prevent empty string passed messages
+#endif
+}
+int _ShowMessage(enum msg_type flag, const char *string, ...)
+{
+	int ret;
+	va_list ap;
+	va_start(ap, string);
+	ret = _vShowMessage(flag, string, ap);
+	va_end(ap);
+	return ret;
+}
+
+// direct printf replacement
+int ShowMessage(const char *string, ...) {
+	int ret;
+	va_list ap;
+	va_start(ap, string);
+	ret = _vShowMessage(MSG_NONE, string, ap);
+	va_end(ap);
+	return ret;
+}
+int ShowStatus(const char *string, ...) {
+	int ret;
+	va_list ap;
+	va_start(ap, string);
+	ret = _vShowMessage(MSG_STATUS, string, ap);
+	va_end(ap);
+	return ret;
+}
+int ShowSQL(const char *string, ...) {
+	int ret;
+	va_list ap;
+	va_start(ap, string);
+	ret = _vShowMessage(MSG_SQL, string, ap);
+	va_end(ap);
+	return ret;
+}
+int ShowInfo(const char *string, ...) {
+	int ret;
+	va_list ap;
+	va_start(ap, string);
+	ret = _vShowMessage(MSG_INFORMATION, string, ap);
+	va_end(ap);
+	return ret;
+}
+int ShowNotice(const char *string, ...) {
+	int ret;
+	va_list ap;
+	va_start(ap, string);
+	ret = _vShowMessage(MSG_NOTICE, string, ap);
+	va_end(ap);
+	return ret;
+}
+int ShowWarning(const char *string, ...) {
+	int ret;
+	va_list ap;
+	va_start(ap, string);
+	ret = _vShowMessage(MSG_WARNING, string, ap);
+	va_end(ap);
+	return ret;
+}
+int ShowDebug(const char *string, ...) {
+	int ret;
+	va_list ap;
+	va_start(ap, string);
+	ret = _vShowMessage(MSG_DEBUG, string, ap);
+	va_end(ap);
+	return ret;
+}
+int ShowError(const char *string, ...) {
+	int ret;
+	va_list ap;
+	va_start(ap, string);
+	ret = _vShowMessage(MSG_ERROR, string, ap);
+	va_end(ap);
+	return ret;
+}
+int ShowFatalError(const char *string, ...) {
+	int ret;
+	va_list ap;
+	va_start(ap, string);
+	ret = _vShowMessage(MSG_FATALERROR, string, ap);
+	va_end(ap);
+	return ret;
+}
diff --git a/src/common/showmsg.h b/src/common/showmsg.h
new file mode 100644
index 0000000..998296b
--- /dev/null
+++ b/src/common/showmsg.h
@@ -0,0 +1,95 @@
+// Copyright (c) Athena Dev Teams - Licensed under GNU GPL
+// For more information, see LICENCE in the main folder
+
+#ifndef _SHOWMSG_H_
+#define _SHOWMSG_H_
+
+// for help with the console colors look here:
+// http://www.edoceo.com/liberum/?doc=printf-with-color
+// some code explanation (used here):
+// \033[2J : clear screen and go up/left (0, 0 position)
+// \033[K  : clear line from actual position to end of the line
+// \033[0m : reset color parameter
+// \033[1m : use bold for font
+
+#define CL_RESET	"\033[0m"
+#define CL_CLS		"\033[2J"
+#define CL_CLL		"\033[K"
+
+// font settings
+#define CL_BOLD		"\033[1m"
+#define CL_NORM		CL_RESET
+#define CL_NORMAL	CL_RESET
+#define CL_NONE		CL_RESET
+// foreground color and bold font (bright color on windows)
+#define CL_WHITE	"\033[1;37m"
+#define CL_GRAY		"\033[1;30m"
+#define CL_RED		"\033[1;31m"
+#define CL_GREEN	"\033[1;32m"
+#define CL_YELLOW	"\033[1;33m"
+#define CL_BLUE		"\033[1;34m"
+#define CL_MAGENTA	"\033[1;35m"
+#define CL_CYAN		"\033[1;36m"
+
+// background color
+#define CL_BG_BLACK		"\033[40m"
+#define CL_BG_RED		"\033[41m"
+#define CL_BG_GREEN		"\033[42m"
+#define CL_BG_YELLOW	"\033[43m"
+#define CL_BG_BLUE		"\033[44m"
+#define CL_BG_MAGENTA	"\033[45m"
+#define CL_BG_CYAN		"\033[46m"
+#define CL_BG_WHITE		"\033[47m"
+// foreground color and normal font (normal color on windows)
+#define CL_LT_BLACK		"\033[0;30m"
+#define CL_LT_RED		"\033[0;31m"
+#define CL_LT_GREEN		"\033[0;32m"
+#define CL_LT_YELLOW	"\033[0;33m"
+#define CL_LT_BLUE		"\033[0;34m"
+#define CL_LT_MAGENTA	"\033[0;35m"
+#define CL_LT_CYAN		"\033[0;36m"
+#define CL_LT_WHITE		"\033[0;37m"
+// foreground color and bold font (bright color on windows)
+#define CL_BT_BLACK		"\033[1;30m"
+#define CL_BT_RED		"\033[1;31m"
+#define CL_BT_GREEN		"\033[1;32m"
+#define CL_BT_YELLOW	"\033[1;33m"
+#define CL_BT_BLUE		"\033[1;34m"
+#define CL_BT_MAGENTA	"\033[1;35m"
+#define CL_BT_CYAN		"\033[1;36m"
+#define CL_BT_WHITE		"\033[1;37m"
+
+#define CL_WTBL			"\033[37;44m"	// white on blue
+#define CL_XXBL			"\033[0;44m"	// default on blue
+#define CL_PASS			"\033[0;32;42m"	// green on green
+
+#define CL_SPACE		"           "	// space aquivalent of the print messages
+
+extern int stdout_with_ansisequence; //If the color ansi sequences are to be used. [flaviojs]
+extern int msg_silent; //Specifies how silent the console is. [Skotlex]
+extern char timestamp_format[20]; //For displaying Timestamps [Skotlex]
+
+enum msg_type {
+	MSG_NONE,
+	MSG_STATUS,
+	MSG_SQL,
+	MSG_INFORMATION,
+	MSG_NOTICE,
+	MSG_WARNING,
+	MSG_DEBUG,
+	MSG_ERROR,
+	MSG_FATALERROR
+};
+
+extern void ClearScreen(void);
+extern int ShowMessage(const char *, ...);
+extern int ShowStatus(const char *, ...);
+extern int ShowSQL(const char *, ...);
+extern int ShowInfo(const char *, ...);
+extern int ShowNotice(const char *, ...);
+extern int ShowWarning(const char *, ...);
+extern int ShowDebug(const char *, ...);
+extern int ShowError(const char *, ...);
+extern int ShowFatalError(const char *, ...);
+
+#endif /* _SHOWMSG_H_ */
diff --git a/src/common/strlib.c b/src/common/strlib.c
new file mode 100644
index 0000000..7f871a2
--- /dev/null
+++ b/src/common/strlib.c
@@ -0,0 +1,1037 @@
+// Copyright (c) Athena Dev Teams - Licensed under GNU GPL
+// For more information, see LICENCE in the main folder
+
+#include "../common/cbasetypes.h"
+#include "../common/malloc.h"
+#include "../common/utils.h"
+#include "../common/showmsg.h"
+#include "strlib.h"
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+
+
+#define J_MAX_MALLOC_SIZE 65535
+
+// escapes a string in-place (' -> \' , \ -> \\ , % -> _)
+char* jstrescape (char* pt)
+{
+	//copy from here
+	char *ptr;
+	int i = 0, j = 0;
+
+	//copy string to temporary
+	CREATE(ptr, char, J_MAX_MALLOC_SIZE);
+	strcpy(ptr,pt);
+
+	while (ptr[i] != '\0') {
+		switch (ptr[i]) {
+			case '\'':
+				pt[j++] = '\\';
+				pt[j++] = ptr[i++];
+				break;
+			case '\\':
+				pt[j++] = '\\';
+				pt[j++] = ptr[i++];
+				break;
+			case '%':
+				pt[j++] = '_'; i++;
+				break;
+			default:
+				pt[j++] = ptr[i++];
+		}
+	}
+	pt[j++] = '\0';
+	aFree(ptr);
+	return pt;
+}
+
+// escapes a string into a provided buffer
+char* jstrescapecpy (char* pt, const char* spt)
+{
+	//copy from here
+	//WARNING: Target string pt should be able to hold strlen(spt)*2, as each time
+	//a escape character is found, the target's final length increases! [Skotlex]
+	int i =0, j=0;
+
+	if (!spt) {	//Return an empty string [Skotlex]
+		pt[0] = '\0';
+		return &pt[0];
+	}
+	
+	while (spt[i] != '\0') {
+		switch (spt[i]) {
+			case '\'':
+				pt[j++] = '\\';
+				pt[j++] = spt[i++];
+				break;
+			case '\\':
+				pt[j++] = '\\';
+				pt[j++] = spt[i++];
+				break;
+			case '%':
+				pt[j++] = '_'; i++;
+				break;
+			default:
+				pt[j++] = spt[i++];
+		}
+	}
+	pt[j++] = '\0';
+	return &pt[0];
+}
+
+// escapes exactly 'size' bytes of a string into a provided buffer
+int jmemescapecpy (char* pt, const char* spt, int size)
+{
+	//copy from here
+	int i =0, j=0;
+
+	while (i < size) {
+		switch (spt[i]) {
+			case '\'':
+				pt[j++] = '\\';
+				pt[j++] = spt[i++];
+				break;
+			case '\\':
+				pt[j++] = '\\';
+				pt[j++] = spt[i++];
+				break;
+			case '%':
+				pt[j++] = '_'; i++;
+				break;
+			default:
+				pt[j++] = spt[i++];
+		}
+	}
+	// copy size is 0 ~ (j-1)
+	return j;
+}
+
+// Function to suppress control characters in a string.
+int remove_control_chars(char* str)
+{
+	int i;
+	int change = 0;
+
+	for(i = 0; str[i]; i++) {
+		if (ISCNTRL(str[i])) {
+			str[i] = '_';
+			change = 1;
+		}
+	}
+
+	return change;
+}
+
+// Removes characters identified by ISSPACE from the start and end of the string
+// NOTE: make sure the string is not const!!
+char* trim(char* str)
+{
+	size_t start;
+	size_t end;
+
+	if( str == NULL )
+		return str;
+
+	// get start position
+	for( start = 0; str[start] && ISSPACE(str[start]); ++start )
+		;
+	// get end position
+	for( end = strlen(str); start < end && str[end-1] && ISSPACE(str[end-1]); --end )
+		;
+	// trim
+	if( start == end )
+		*str = '\0';// empty string
+	else
+	{// move string with nul terminator
+		str[end] = '\0';
+		memmove(str,str+start,end-start+1);
+	}
+	return str;
+}
+
+// Converts one or more consecutive occurences of the delimiters into a single space
+// and removes such occurences from the beginning and end of string
+// NOTE: make sure the string is not const!!
+char* normalize_name(char* str,const char* delims)
+{
+	char* in = str;
+	char* out = str;
+	int put_space = 0;
+
+	if( str == NULL || delims == NULL )
+		return str;
+
+	// trim start of string
+	while( *in && strchr(delims,*in) )
+		++in;
+	while( *in )
+	{
+		if( put_space )
+		{// replace trim characters with a single space
+			*out = ' ';
+			++out;
+		}
+		// copy non trim characters
+		while( *in && !strchr(delims,*in) )
+		{
+			*out = *in;
+			++out;
+			++in;
+		}
+		// skip trim characters
+		while( *in && strchr(delims,*in) )
+			++in;
+		put_space = 1;
+	}
+	*out = '\0';
+	return str;
+}
+
+//stristr: Case insensitive version of strstr, code taken from 
+//http://www.daniweb.com/code/snippet313.html, Dave Sinkula
+//
+const char* stristr(const char* haystack, const char* needle)
+{
+	if ( !*needle )
+	{
+		return haystack;
+	}
+	for ( ; *haystack; ++haystack )
+	{
+		if ( TOUPPER(*haystack) == TOUPPER(*needle) )
+		{
+			// matched starting char -- loop through remaining chars
+			const char *h, *n;
+			for ( h = haystack, n = needle; *h && *n; ++h, ++n )
+			{
+				if ( TOUPPER(*h) != TOUPPER(*n) )
+				{
+					break;
+				}
+			}
+			if ( !*n ) // matched all of 'needle' to null termination
+			{
+				return haystack; // return the start of the match
+			}
+		}
+	}
+	return 0;
+}
+
+#ifdef __WIN32
+char* _strtok_r(char *s1, const char *s2, char **lasts)
+{
+	char *ret;
+
+	if (s1 == NULL)
+		s1 = *lasts;
+	while(*s1 && strchr(s2, *s1))
+		++s1;
+	if(*s1 == '\0')
+		return NULL;
+	ret = s1;
+	while(*s1 && !strchr(s2, *s1))
+		++s1;
+	if(*s1)
+		*s1++ = '\0';
+	*lasts = s1;
+	return ret;
+}
+#endif
+
+#if !(defined(WIN32) && defined(_MSC_VER) && _MSC_VER >= 1400) && !defined(CYGWIN)
+/* Find the length of STRING, but scan at most MAXLEN characters.
+   If no '\0' terminator is found in that many characters, return MAXLEN.  */
+size_t strnlen (const char* string, size_t maxlen)
+{
+  const char* end = memchr (string, '\0', maxlen);
+  return end ? (size_t) (end - string) : maxlen;
+}
+#endif
+
+//----------------------------------------------------
+// E-mail check: return 0 (not correct) or 1 (valid).
+//----------------------------------------------------
+/*
+int e_mail_check(char* email)
+{
+	char ch;
+	char* last_arobas;
+	size_t len = strlen(email);
+
+	// athena limits
+	if (len < 3 || len > 39)
+		return 0;
+
+	// part of RFC limits (official reference of e-mail description)
+	if (strchr(email, '@') == NULL || email[len-1] == '@')
+		return 0;
+
+	if (email[len-1] == '.')
+		return 0;
+
+	last_arobas = strrchr(email, '@');
+
+	if (strstr(last_arobas, "@.") != NULL || strstr(last_arobas, "..") != NULL)
+		return 0;
+
+	for(ch = 1; ch < 32; ch++)
+		if (strchr(last_arobas, ch) != NULL)
+			return 0;
+
+	if (strchr(last_arobas, ' ') != NULL || strchr(last_arobas, ';') != NULL)
+		return 0;
+
+	// all correct
+	return 1;
+}
+*/
+
+//--------------------------------------------------
+// Return numerical value of a switch configuration
+// on/off, english, franais, deutsch, espaol
+//--------------------------------------------------
+int config_switch(const char* str)
+{
+	if (strcmpi(str, "on") == 0 || strcmpi(str, "yes") == 0 || strcmpi(str, "oui") == 0 || strcmpi(str, "ja") == 0 || strcmpi(str, "si") == 0)
+		return 1;
+	if (strcmpi(str, "off") == 0 || strcmpi(str, "no") == 0 || strcmpi(str, "non") == 0 || strcmpi(str, "nein") == 0)
+		return 0;
+
+	return (int)strtol(str, NULL, 0);
+}
+
+/// always nul-terminates the string
+char* safestrncpy(char* dst, const char* src, size_t n)
+{
+	char* ret;
+	ret = strncpy(dst, src, n);
+	if( ret != NULL )
+		ret[n - 1] = '\0';
+	return ret;
+}
+
+/// doesn't crash on null pointer
+size_t safestrnlen(const char* string, size_t maxlen)
+{
+	return ( string != NULL ) ? strnlen(string, maxlen) : 0;
+}
+
+/// Works like snprintf, but always nul-terminates the buffer.
+/// Returns the size of the string (without nul-terminator)
+/// or -1 if the buffer is too small.
+///
+/// @param buf Target buffer
+/// @param sz Size of the buffer (including nul-terminator)
+/// @param fmt Format string
+/// @param ... Format arguments
+/// @return The size of the string or -1 if the buffer is too small
+int safesnprintf(char* buf, size_t sz, const char* fmt, ...)
+{
+	va_list ap;
+	int ret;
+
+	va_start(ap,fmt);
+	ret = vsnprintf(buf, sz, fmt, ap);
+	va_end(ap);
+	if( ret < 0 || (size_t)ret >= sz )
+	{// overflow
+		buf[sz-1] = '\0';// always nul-terminate
+		return -1;
+	}
+	return ret;
+}
+
+/// Returns the line of the target position in the string.
+/// Lines start at 1.
+int strline(const char* str, size_t pos)
+{
+	const char* target;
+	int line;
+
+	if( str == NULL || pos == 0 )
+		return 1;
+
+	target = str+pos;
+	for( line = 1; ; ++line )
+	{
+		str = strchr(str, '\n');
+		if( str == NULL || target <= str )
+			break;// found target line
+		++str;// skip newline
+	}
+	return line;
+}
+
+
+
+/////////////////////////////////////////////////////////////////////
+/// Parses a delim-separated string.
+/// Starts parsing at startoff and fills the pos array with position pairs.
+/// out_pos[0] and out_pos[1] are the start and end of line.
+/// Other position pairs are the start and end of fields.
+/// Returns the number of fields found or -1 if an error occurs.
+/// 
+/// out_pos can be NULL.
+/// If a line terminator is found, the end position is placed there.
+/// out_pos[2] and out_pos[3] for the first field, out_pos[4] and out_pos[5] 
+/// for the seconds field and so on.
+/// Unfilled positions are set to -1.
+/// 
+/// @param str String to parse
+/// @param len Length of the string
+/// @param startoff Where to start parsing
+/// @param delim Field delimiter
+/// @param out_pos Array of resulting positions
+/// @param npos Size of the pos array
+/// @param opt Options that determine the parsing behaviour
+/// @return Number of fields found in the string or -1 if an error occured
+int sv_parse(const char* str, int len, int startoff, char delim, int* out_pos, int npos, enum e_svopt opt)
+{
+	int i;
+	int count;
+	enum {
+		START_OF_FIELD,
+		PARSING_FIELD,
+		PARSING_C_ESCAPE,
+		END_OF_FIELD,
+		TERMINATE,
+		END
+	} state;
+
+	// check pos/npos
+	if( out_pos == NULL ) npos = 0;
+	for( i = 0; i < npos; ++i )
+		out_pos[i] = -1;
+
+	// check opt
+	if( delim == '\n' && (opt&(SV_TERMINATE_CRLF|SV_TERMINATE_LF)) )
+	{
+		ShowError("sv_parse: delimiter '\\n' is not compatible with options SV_TERMINATE_LF or SV_TERMINATE_CRLF.\n");
+		return -1;// error
+	}
+	if( delim == '\r' && (opt&(SV_TERMINATE_CRLF|SV_TERMINATE_CR)) )
+	{
+		ShowError("sv_parse: delimiter '\\r' is not compatible with options SV_TERMINATE_CR or SV_TERMINATE_CRLF.\n");
+		return -1;// error
+	}
+
+	// check str
+	if( str == NULL )
+		return 0;// nothing to parse
+
+#define IS_END() ( i >= len )
+#define IS_DELIM() ( str[i] == delim )
+#define IS_TERMINATOR() ( \
+	((opt&SV_TERMINATE_LF) && str[i] == '\n') || \
+	((opt&SV_TERMINATE_CR) && str[i] == '\r') || \
+	((opt&SV_TERMINATE_CRLF) && i+1 < len && str[i] == '\r' && str[i+1] == '\n') )
+#define IS_C_ESCAPE() ( (opt&SV_ESCAPE_C) && str[i] == '\\' )
+#define SET_FIELD_START() if( npos > count*2+2 ) out_pos[count*2+2] = i
+#define SET_FIELD_END() if( npos > count*2+3 ) out_pos[count*2+3] = i; ++count
+
+	i = startoff;
+	count = 0;
+	state = START_OF_FIELD;
+	if( npos > 0 ) out_pos[0] = startoff;// start
+	while( state != END )
+	{
+		if( npos > 1 ) out_pos[1] = i;// end
+		switch( state )
+		{
+		case START_OF_FIELD:// record start of field and start parsing it
+			SET_FIELD_START();
+			state = PARSING_FIELD;
+			break;
+
+		case PARSING_FIELD:// skip field character
+			if( IS_END() || IS_DELIM() || IS_TERMINATOR() )
+				state = END_OF_FIELD;
+			else if( IS_C_ESCAPE() )
+				state = PARSING_C_ESCAPE;
+			else
+				++i;// normal character
+			break;
+
+		case PARSING_C_ESCAPE:// skip escape sequence (validates it too)
+			{
+				++i;// '\\'
+				if( IS_END() )
+				{
+					ShowError("sv_parse: empty escape sequence\n");
+					return -1;
+				}
+				if( str[i] == 'x' )
+				{// hex escape
+					++i;// 'x'
+					if( IS_END() || !ISXDIGIT(str[i]) )
+					{
+						ShowError("sv_parse: \\x with no following hex digits\n");
+						return -1;
+					}
+					do{
+						++i;// hex digit
+					}while( !IS_END() && ISXDIGIT(str[i]));
+				}
+				else if( str[i] == '0' || str[i] == '1' || str[i] == '2' )
+				{// octal escape
+					++i;// octal digit
+					if( !IS_END() && str[i] >= '0' && str[i] <= '7' )
+						++i;// octal digit
+					if( !IS_END() && str[i] >= '0' && str[i] <= '7' )
+						++i;// octal digit
+				}
+				else if( strchr(SV_ESCAPE_C_SUPPORTED, str[i]) )
+				{// supported escape character
+					++i;
+				}
+				else
+				{
+					ShowError("sv_parse: unknown escape sequence \\%c\n", str[i]);
+					return -1;
+				}
+				state = PARSING_FIELD;
+				break;
+			}
+
+		case END_OF_FIELD:// record end of field and continue
+			SET_FIELD_END();
+			if( IS_END() )
+				state = END;
+			else if( IS_DELIM() )
+			{
+				++i;// delim
+				state = START_OF_FIELD;
+			}
+			else if( IS_TERMINATOR() )
+				state = TERMINATE;
+			else
+				state = START_OF_FIELD;
+			break;
+
+		case TERMINATE:
+#if 0
+			// skip line terminator
+			if( (opt&SV_TERMINATE_CRLF) && i+1 < len && str[i] == '\r' && str[i+1] == '\n' )
+				i += 2;// CRLF
+			else
+				++i;// CR or LF
+#endif
+			state = END;
+			break;
+        case END:
+            break;
+		}
+	}
+
+#undef IS_END
+#undef IS_DELIM
+#undef IS_TERMINATOR
+#undef IS_C_ESCAPE
+#undef SET_FIELD_START
+#undef SET_FIELD_END
+
+	return count;
+}
+
+/// Splits a delim-separated string.
+/// WARNING: this function modifies the input string
+/// Starts splitting at startoff and fills the out_fields array.
+/// out_fields[0] is the start of the next line.
+/// Other entries are the start of fields (nul-teminated).
+/// Returns the number of fields found or -1 if an error occurs.
+/// 
+/// out_fields can be NULL.
+/// Fields that don't fit in out_fields are not nul-terminated.
+/// Extra entries in out_fields are filled with the end of the last field (empty string).
+/// 
+/// @param str String to parse
+/// @param len Length of the string
+/// @param startoff Where to start parsing
+/// @param delim Field delimiter
+/// @param out_fields Array of resulting fields
+/// @param nfields Size of the field array
+/// @param opt Options that determine the parsing behaviour
+/// @return Number of fields found in the string or -1 if an error occured
+int sv_split(char* str, int len, int startoff, char delim, char** out_fields, int nfields, enum e_svopt opt)
+{
+	int pos[1024];
+	int i;
+	int done;
+	char* end;
+	int ret = sv_parse(str, len, startoff, delim, pos, ARRAYLENGTH(pos), opt);
+
+	if( ret == -1 || out_fields == NULL || nfields <= 0 )
+		return ret; // nothing to do
+
+	// next line
+	end = str + pos[1];
+	if( end[0] == '\0' )
+	{
+		*out_fields = end;
+	}
+	else if( (opt&SV_TERMINATE_LF) && end[0] == '\n' )
+	{
+		if( !(opt&SV_KEEP_TERMINATOR) )
+			end[0] = '\0';
+		*out_fields = end + 1;
+	}
+	else if( (opt&SV_TERMINATE_CRLF) && end[0] == '\r' && end[1] == '\n' )
+	{
+		if( !(opt&SV_KEEP_TERMINATOR) )
+			end[0] = end[1] = '\0';
+		*out_fields = end + 2;
+	}
+	else if( (opt&SV_TERMINATE_LF) && end[0] == '\r' )
+	{
+		if( !(opt&SV_KEEP_TERMINATOR) )
+			end[0] = '\0';
+		*out_fields = end + 1;
+	}
+	else
+	{
+		ShowError("sv_split: unknown line delimiter 0x02%x.\n", (unsigned char)end[0]);
+		return -1;// error
+	}
+	++out_fields;
+	--nfields;
+
+	// fields
+	i = 2;
+	done = 0;
+	while( done < ret && nfields > 0 )
+	{
+		if( i < ARRAYLENGTH(pos) )
+		{// split field
+			*out_fields = str + pos[i];
+			end = str + pos[i+1];
+			*end = '\0';
+			// next field
+			i += 2;
+			++done;
+			++out_fields;
+			--nfields;
+		}
+		else
+		{// get more fields
+			sv_parse(str, len, pos[i-1] + 1, delim, pos, ARRAYLENGTH(pos), opt);
+			i = 2;
+		}
+	}
+	// remaining fields
+	for( i = 0; i < nfields; ++i )
+		out_fields[i] = end;
+	return ret;
+}
+
+/// Escapes src to out_dest according to the format of the C compiler.
+/// Returns the length of the escaped string.
+/// out_dest should be len*4+1 in size.
+///
+/// @param out_dest Destination buffer
+/// @param src Source string
+/// @param len Length of the source string
+/// @param escapes Extra characters to be escaped
+/// @return Length of the escaped string
+size_t sv_escape_c(char* out_dest, const char* src, size_t len, const char* escapes)
+{
+	size_t i;
+	size_t j;
+
+	if( out_dest == NULL )
+		return 0;// nothing to do
+	if( src == NULL )
+	{// nothing to escape
+		*out_dest = 0;
+		return 0;
+	}
+	if( escapes == NULL )
+		escapes = "";
+
+	for( i = 0, j = 0; i < len; ++i )
+	{
+		switch( src[i] )
+		{
+		case '\0':// octal 0
+			out_dest[j++] = '\\';
+			out_dest[j++] = '0';
+			out_dest[j++] = '0';
+			out_dest[j++] = '0';
+			break;
+		case '\r':// carriage return
+			out_dest[j++] = '\\';
+			out_dest[j++] = 'r';
+			break;
+		case '\n':// line feed
+			out_dest[j++] = '\\';
+			out_dest[j++] = 'n';
+			break;
+		case '\\':// escape character
+			out_dest[j++] = '\\';
+			out_dest[j++] = '\\';
+			break;
+		default:
+			if( strchr(escapes,src[i]) )
+			{// escapes to octal
+				out_dest[j++] = '\\';
+				out_dest[j++] = '0'+((char)(((unsigned char)src[i]&0700)>>6));
+				out_dest[j++] = '0'+((char)(((unsigned char)src[i]&0070)>>3));
+				out_dest[j++] = '0'+((char)(((unsigned char)src[i]&0007)   ));
+			}
+			else
+				out_dest[j++] = src[i];
+			break;
+		}
+	}
+	out_dest[j] = 0;
+	return j;
+}
+
+/// Unescapes src to out_dest according to the format of the C compiler.
+/// Returns the length of the unescaped string.
+/// out_dest should be len+1 in size and can be the same buffer as src.
+///
+/// @param out_dest Destination buffer
+/// @param src Source string
+/// @param len Length of the source string
+/// @return Length of the escaped string
+size_t sv_unescape_c(char* out_dest, const char* src, size_t len)
+{
+	static unsigned char low2hex[256] = {
+		0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 0x0?
+		0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 0x1?
+		0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 0x2?
+		0,  1,  2,  3,  4,  5,  6, 7, 8, 9, 0, 0, 0, 0, 0, 0,// 0x3?
+		0, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 0x4?
+		0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 0x5?
+		0, 10, 11, 12, 13, 14, 15, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 0x6?
+		0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 0x7?
+		0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 0x8?
+		0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 0x9?
+		0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 0xA?
+		0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 0xB?
+		0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 0xC?
+		0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 0xD?
+		0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0,// 0xE?
+		0,  0,  0,  0,  0,  0,  0, 0, 0, 0, 0, 0, 0, 0, 0, 0 // 0xF?
+	};
+	size_t i;
+	size_t j;
+
+	for( i = 0, j = 0; i < len; )
+	{
+		if( src[i] == '\\' )
+		{
+			++i;// '\\'
+			if( i >= len )
+				ShowWarning("sv_unescape_c: empty escape sequence\n");
+			else if( src[i] == 'x' )
+			{// hex escape sequence
+				unsigned char c = 0;
+				unsigned char inrange = 1;
+
+				++i;// 'x'
+				if( i >= len || !ISXDIGIT(src[i]) )
+				{
+					ShowWarning("sv_unescape_c: \\x with no following hex digits\n");
+					continue;
+				}
+				do{
+					if( c > 0x0F && inrange )
+					{
+						ShowWarning("sv_unescape_c: hex escape sequence out of range\n");
+						inrange = 0;
+					}
+					c = (c<<4)|low2hex[(unsigned char)src[i]];// hex digit
+					++i;
+				}while( i < len && ISXDIGIT(src[i]) );
+				out_dest[j++] = (char)c;
+			}
+			else if( src[i] == '0' || src[i] == '1' || src[i] == '2' || src[i] == '3' )
+			{// octal escape sequence (255=0377)
+				unsigned char c = src[i]-'0';
+				++i;// '0', '1', '2' or '3'
+				if( i < len && src[i] >= '0' && src[i] <= '7' )
+				{
+					c = (c<<3)|(src[i]-'0');
+					++i;// octal digit
+				}
+				if( i < len && src[i] >= '0' && src[i] <= '7' )
+				{
+					c = (c<<3)|(src[i]-'0');
+					++i;// octal digit
+				}
+				out_dest[j++] = (char)c;
+			}
+			else
+			{// other escape sequence
+				if( strchr(SV_ESCAPE_C_SUPPORTED, src[i]) == NULL )
+					ShowWarning("sv_unescape_c: unknown escape sequence \\%c\n", src[i]);
+				switch( src[i] )
+				{
+				case 'a': out_dest[j++] = '\a'; break;
+				case 'b': out_dest[j++] = '\b'; break;
+				case 't': out_dest[j++] = '\t'; break;
+				case 'n': out_dest[j++] = '\n'; break;
+				case 'v': out_dest[j++] = '\v'; break;
+				case 'f': out_dest[j++] = '\f'; break;
+				case 'r': out_dest[j++] = '\r'; break;
+				case '?': out_dest[j++] = '\?'; break;
+				default: out_dest[j++] = src[i]; break;
+				}
+				++i;// escaped character
+			}
+		}
+		else
+			out_dest[j++] = src[i++];// normal character
+	}
+	out_dest[j] = 0;
+	return j;
+}
+
+/// Skips a C escape sequence (starting with '\\').
+const char* skip_escaped_c(const char* p)
+{
+	if( p && *p == '\\' )
+	{
+		++p;
+		switch( *p )
+		{
+		case 'x':// hexadecimal
+			++p;
+			while( ISXDIGIT(*p) )
+				++p;
+			break;
+		case '0':
+		case '1':
+		case '2':
+		case '3':// octal
+			++p;
+			if( *p >= '0' && *p <= '7' )
+				++p;
+			if( *p >= '0' && *p <= '7' )
+				++p;
+			break;
+		default:
+			if( *p && strchr(SV_ESCAPE_C_SUPPORTED, *p) )
+				++p;
+		}
+	}
+	return p;
+}
+
+
+/// Opens and parses a file containing delim-separated columns, feeding them to the specified callback function row by row.
+/// Tracks the progress of the operation (current line number, number of successfully processed rows).
+/// Returns 'true' if it was able to process the specified file, or 'false' if it could not be read.
+///
+/// @param directory Directory
+/// @param filename File to process
+/// @param delim Field delimiter
+/// @param mincols Minimum number of columns of a valid row
+/// @param maxcols Maximum number of columns of a valid row
+/// @param parseproc User-supplied row processing function
+/// @return true on success, false if file could not be opened
+bool sv_readdb(const char* directory, const char* filename, char delim, int mincols, int maxcols, int maxrows, bool (*parseproc)(char* fields[], int columns, int current))
+{
+	FILE* fp;
+	int lines = 0;
+	int entries = 0;
+	char* fields[64]; // room for 63 fields ([0] is reserved)
+	int columns;
+	char path[1024], line[1024];
+
+	if( maxcols > ARRAYLENGTH(fields)-1 )
+	{
+		ShowError("sv_readdb: Insufficient column storage in parser for file \"%s\" (want %d, have only %d). Increase the capacity in the source code please.\n", path, maxcols, ARRAYLENGTH(fields)-1);
+		return false;
+	}
+
+	// open file
+	snprintf(path, sizeof(path), "%s/%s", directory, filename);
+	fp = fopen(path, "r");
+	if( fp == NULL )
+	{
+		ShowError("sv_readdb: can't read %s\n", path);
+		return false;
+	}
+
+	// process rows one by one
+	while( fgets(line, sizeof(line), fp) )
+	{
+		lines++;
+		if( line[0] == '/' && line[1] == '/' )
+			continue;
+		//TODO: strip trailing // comment
+		//TODO: strip trailing whitespace
+		if( line[0] == '\0' || line[0] == '\n' || line[0] == '\r')
+			continue;
+
+		columns = sv_split(line, strlen(line), 0, delim, fields, ARRAYLENGTH(fields), (e_svopt)(SV_TERMINATE_LF|SV_TERMINATE_CRLF));
+
+		if( columns < mincols )
+		{
+			ShowError("sv_readdb: Insufficient columns in line %d of \"%s\" (found %d, need at least %d).\n", lines, path, columns, mincols);
+			continue; // not enough columns
+		}
+		if( columns > maxcols )
+		{
+			ShowError("sv_readdb: Too many columns in line %d of \"%s\" (found %d, maximum is %d).\n", lines, path, columns, maxcols );
+			continue; // too many columns
+		}
+		if( entries == maxrows )
+		{
+			ShowError("sv_readdb: Reached the maximum allowed number of entries (%d) when parsing file \"%s\".\n", maxrows, path);
+			break;
+		}
+
+		// parse this row
+		if( !parseproc(fields+1, columns, entries) )
+		{
+			ShowError("sv_readdb: Could not process contents of line %d of \"%s\".\n", lines, path);
+			continue; // invalid row contents
+		}
+
+		// success!
+		entries++;
+	}
+
+	fclose(fp);
+	ShowStatus("Done reading '"CL_WHITE"%d"CL_RESET"' entries in '"CL_WHITE"%s"CL_RESET"'.\n", entries, path);
+
+	return true;
+}
+
+
+/////////////////////////////////////////////////////////////////////
+// StringBuf - dynamic string
+//
+// @author MouseJstr (original)
+
+/// Allocates a StringBuf
+StringBuf* StringBuf_Malloc() 
+{
+	StringBuf* self;
+	CREATE(self, StringBuf, 1);
+	StringBuf_Init(self);
+	return self;
+}
+
+/// Initializes a previously allocated StringBuf
+void StringBuf_Init(StringBuf* self)
+{
+	self->max_ = 1024;
+	self->ptr_ = self->buf_ = (char*)aMallocA(self->max_ + 1);
+}
+
+/// Appends the result of printf to the StringBuf
+int StringBuf_Printf(StringBuf* self, const char* fmt, ...)
+{
+	int len;
+	va_list ap;
+
+	va_start(ap, fmt);
+	len = StringBuf_Vprintf(self, fmt, ap);
+	va_end(ap);
+
+	return len;
+}
+
+/// Appends the result of vprintf to the StringBuf
+int StringBuf_Vprintf(StringBuf* self, const char* fmt, va_list ap)
+{
+	int n, size, off;
+
+	for(;;)
+	{
+		/* Try to print in the allocated space. */
+		size = self->max_ - (self->ptr_ - self->buf_);
+		n = vsnprintf(self->ptr_, size, fmt, ap);
+		/* If that worked, return the length. */
+		if( n > -1 && n < size )
+		{
+			self->ptr_ += n;
+			return (int)(self->ptr_ - self->buf_);
+		}
+		/* Else try again with more space. */
+		self->max_ *= 2; // twice the old size
+		off = (int)(self->ptr_ - self->buf_);
+		self->buf_ = (char*)aRealloc(self->buf_, self->max_ + 1);
+		self->ptr_ = self->buf_ + off;
+	}
+}
+
+/// Appends the contents of another StringBuf to the StringBuf
+int StringBuf_Append(StringBuf* self, const StringBuf* sbuf)
+{
+	int available = self->max_ - (self->ptr_ - self->buf_);
+	int needed = (int)(sbuf->ptr_ - sbuf->buf_);
+
+	if( needed >= available )
+	{
+		int off = (int)(self->ptr_ - self->buf_);
+		self->max_ += needed;
+		self->buf_ = (char*)aRealloc(self->buf_, self->max_ + 1);
+		self->ptr_ = self->buf_ + off;
+	}
+
+	memcpy(self->ptr_, sbuf->buf_, needed);
+	self->ptr_ += needed;
+	return (int)(self->ptr_ - self->buf_);
+}
+
+// Appends str to the StringBuf
+int StringBuf_AppendStr(StringBuf* self, const char* str) 
+{
+	int available = self->max_ - (self->ptr_ - self->buf_);
+	int needed = (int)strlen(str);
+
+	if( needed >= available )
+	{// not enough space, expand the buffer (minimum expansion = 1024)
+		int off = (int)(self->ptr_ - self->buf_);
+		self->max_ += max(needed, 1024);
+		self->buf_ = (char*)aRealloc(self->buf_, self->max_ + 1);
+		self->ptr_ = self->buf_ + off;
+	}
+
+	memcpy(self->ptr_, str, needed);
+	self->ptr_ += needed;
+	return (int)(self->ptr_ - self->buf_);
+}
+
+// Returns the length of the data in the Stringbuf
+int StringBuf_Length(StringBuf* self) 
+{
+	return (int)(self->ptr_ - self->buf_);
+}
+
+/// Returns the data in the StringBuf
+char* StringBuf_Value(StringBuf* self) 
+{
+	*self->ptr_ = '\0';
+	return self->buf_;
+}
+
+/// Clears the contents of the StringBuf
+void StringBuf_Clear(StringBuf* self) 
+{
+	self->ptr_ = self->buf_;
+}
+
+/// Destroys the StringBuf
+void StringBuf_Destroy(StringBuf* self)
+{
+	aFree(self->buf_);
+	self->ptr_ = self->buf_ = 0;
+	self->max_ = 0;
+}
+
+// Frees a StringBuf returned by StringBuf_Malloc
+void StringBuf_Free(StringBuf* self) 
+{
+	StringBuf_Destroy(self);
+	aFree(self);
+}
diff --git a/src/common/strlib.h b/src/common/strlib.h
new file mode 100644
index 0000000..074c7ea
--- /dev/null
+++ b/src/common/strlib.h
@@ -0,0 +1,124 @@
+// Copyright (c) Athena Dev Teams - Licensed under GNU GPL
+// For more information, see LICENCE in the main folder
+
+#ifndef _STRLIB_H_
+#define _STRLIB_H_
+
+#ifndef _CBASETYPES_H_
+#include "../common/cbasetypes.h"
+#endif
+#include <stdarg.h>
+
+char* jstrescape (char* pt);
+char* jstrescapecpy (char* pt, const char* spt);
+int jmemescapecpy (char* pt, const char* spt, int size);
+
+int remove_control_chars(char* str);
+char* trim(char* str);
+char* normalize_name(char* str,const char* delims);
+const char *stristr(const char *haystack, const char *needle);
+
+#ifdef WIN32
+#define HAVE_STRTOK_R
+#define strtok_r(s,delim,save_ptr) _strtok_r((s),(delim),(save_ptr))
+char* _strtok_r(char* s1, const char* s2, char** lasts);
+#endif
+
+#if !(defined(WIN32) && defined(_MSC_VER) && _MSC_VER >= 1400) && !defined(CYGWIN)
+size_t strnlen (const char* string, size_t maxlen);
+#endif
+
+int e_mail_check(char* email);
+int config_switch(const char* str);
+
+/// always nul-terminates the string
+char* safestrncpy(char* dst, const char* src, size_t n);
+
+/// doesn't crash on null pointer
+size_t safestrnlen(const char* string, size_t maxlen);
+
+/// Works like snprintf, but always nul-terminates the buffer.
+/// Returns the size of the string (without nul-terminator)
+/// or -1 if the buffer is too small.
+int safesnprintf(char* buf, size_t sz, const char* fmt, ...);
+
+/// Returns the line of the target position in the string.
+/// Lines start at 1.
+int strline(const char* str, size_t pos);
+
+
+
+/// Bitfield determining the behaviour of sv_parse and sv_split.
+typedef enum e_svopt
+{
+	// default: no escapes and no line terminator
+	SV_NOESCAPE_NOTERMINATE = 0,
+	// Escapes according to the C compiler.
+	SV_ESCAPE_C = 1,
+	// Line terminators
+	SV_TERMINATE_LF = 2,
+	SV_TERMINATE_CRLF = 4,
+	SV_TERMINATE_CR = 8,
+	// If sv_split keeps the end of line terminator, instead of replacing with '\0'
+	SV_KEEP_TERMINATOR = 16
+} e_svopt;
+
+/// Other escape sequences supported by the C compiler.
+#define SV_ESCAPE_C_SUPPORTED "abtnvfr\?\"'\\"
+
+/// Parses a delim-separated string.
+/// Starts parsing at startoff and fills the pos array with position pairs.
+/// out_pos[0] and out_pos[1] are the start and end of line.
+/// Other position pairs are the start and end of fields.
+/// Returns the number of fields found or -1 if an error occurs.
+int sv_parse(const char* str, int len, int startoff, char delim, int* out_pos, int npos, enum e_svopt opt);
+
+/// Splits a delim-separated string.
+/// WARNING: this function modifies the input string
+/// Starts splitting at startoff and fills the out_fields array.
+/// out_fields[0] is the start of the next line.
+/// Other entries are the start of fields (nul-teminated).
+/// Returns the number of fields found or -1 if an error occurs.
+int sv_split(char* str, int len, int startoff, char delim, char** out_fields, int nfields, enum e_svopt opt);
+
+/// Escapes src to out_dest according to the format of the C compiler.
+/// Returns the length of the escaped string.
+/// out_dest should be len*4+1 in size.
+size_t sv_escape_c(char* out_dest, const char* src, size_t len, const char* escapes);
+
+/// Unescapes src to out_dest according to the format of the C compiler.
+/// Returns the length of the unescaped string.
+/// out_dest should be len+1 in size and can be the same buffer as src.
+size_t sv_unescape_c(char* out_dest, const char* src, size_t len);
+
+/// Skips a C escape sequence (starting with '\\').
+const char* skip_escaped_c(const char* p);
+
+/// Opens and parses a file containing delim-separated columns, feeding them to the specified callback function row by row.
+/// Tracks the progress of the operation (current line number, number of successfully processed rows).
+/// Returns 'true' if it was able to process the specified file, or 'false' if it could not be read.
+bool sv_readdb(const char* directory, const char* filename, char delim, int mincols, int maxcols, int maxrows, bool (*parseproc)(char* fields[], int columns, int current));
+
+
+/// StringBuf - dynamic string
+struct StringBuf
+{
+	char *buf_;
+	char *ptr_;
+	unsigned int max_;
+};
+typedef struct StringBuf StringBuf;
+
+StringBuf* StringBuf_Malloc(void);
+void StringBuf_Init(StringBuf* self);
+int StringBuf_Printf(StringBuf* self, const char* fmt, ...);
+int StringBuf_Vprintf(StringBuf* self, const char* fmt, va_list args);
+int StringBuf_Append(StringBuf* self, const StringBuf *sbuf);
+int StringBuf_AppendStr(StringBuf* self, const char* str);
+int StringBuf_Length(StringBuf* self);
+char* StringBuf_Value(StringBuf* self);
+void StringBuf_Clear(StringBuf* self);
+void StringBuf_Destroy(StringBuf* self);
+void StringBuf_Free(StringBuf* self);
+
+#endif /* _STRLIB_H_ */
diff --git a/src/map/Makefile b/src/map/Makefile
index 10ef878..da96d7d 100644
--- a/src/map/Makefile
+++ b/src/map/Makefile
@@ -7,7 +7,7 @@ txt: obj map-server
 obj:
 	mkdir obj
 
-COMMON_OBJ = ../common/core.o ../common/socket.o ../common/timer.o ../common/grfio.o ../common/db.o ../common/lock.o ../common/nullpo.o ../common/malloc.o ../common/mt_rand.o ../common/md5calc.o
+COMMON_OBJ = ../common/core.o ../common/socket.o ../common/timer.o ../common/grfio.o ../common/db.o ../common/lock.o ../common/nullpo.o ../common/malloc.o ../common/showmsg.o ../common/strlib.o ../common/mt_rand.o ../common/md5calc.o
 
 LIBS = -lz -lm
 
diff --git a/src/map/script.c b/src/map/script.c
index d787956..7a647fc 100644
--- a/src/map/script.c
+++ b/src/map/script.c
@@ -39,6 +39,9 @@
 #include "skill.h"
 #include "storage.h"
 
+#include "../common/showmsg.h"
+#include "../common/strlib.h"
+
 #ifdef MEMWATCH
 #include "memwatch.h"
 #endif
@@ -134,6 +137,10 @@ enum
 static unsigned char *script_buf;
 static int script_pos, script_size;
 
+#define not_server_variable(prefix) ( (prefix) != '$' && (prefix) != '.')
+#define not_array_variable(prefix) ( (prefix) != '$' && (prefix) != '@' && (prefix) != '.' )
+#define is_string_variable(name) ( (name)[strlen(name) - 1] == '$' )
+
 char *str_buf;
 int  str_pos, str_size;
 static struct
@@ -401,6 +408,7 @@ int  buildin_npcspeed (struct script_state *st); // [Valaris]
 int  buildin_hasitems (struct script_state *st);    // [Valaris]
 int  buildin_getlook (struct script_state *st); //Lorky [Lupus]
 int  buildin_getsavepoint (struct script_state *st);    //Lorky [Lupus]
+int  buildin_getmapxy (struct script_state *st);    //Lorky [Lupus]
 int  buildin_getpartnerid (struct script_state *st);    // [Fate]
 int  buildin_areatimer (struct script_state *st);   // [Jaxad0127]
 int  buildin_isin (struct script_state *st);    // [Jaxad0127]
@@ -825,6 +833,8 @@ struct
     {
     buildin_getsavepoint, "getsavepoint", "i"},
     {
+    buildin_getmapxy, "getmapxy", "siii*"},
+    {
     buildin_areatimer, "areatimer", "siiiiis"},
     {
     buildin_isin, "isin", "siiii"},
@@ -7574,6 +7584,155 @@ BUILDIN_FUNC(getsavepoint)
 }
 
 /*==========================================
+  * Get position for  char/npc/pet/mob objects. Added by Lorky
+  *
+  *     int getMapXY(MapName$,MapX,MapY,type,[CharName$]);
+  *             where type:
+  *                     MapName$ - String variable for output map name
+  *                     MapX     - Integer variable for output coord X
+  *                     MapY     - Integer variable for output coord Y
+  *                     type     - type of object
+  *                                0 - Character coord
+  *                                1 - NPC coord
+  *                                2 - Pet coord
+  *                                3 - Mob coord (not released)
+  *                                4 - Homun coord
+  *                     CharName$ - Name object. If miss or "this" the current object
+  *
+  *             Return:
+  *                     0        - success
+  *                     -1       - some error, MapName$,MapX,MapY contains unknown value.
+  *------------------------------------------*/
+BUILDIN_FUNC(getmapxy)
+{
+    struct block_list *bl = NULL;
+    TBL_PC *sd = NULL;
+
+    int num;
+    char *name;
+    char prefix;
+
+    int x,y,type;
+    char mapname[MAP_NAME_LENGTH];
+    memset(mapname, 0, sizeof(mapname));
+
+    if (!data_isreference(script_getdata(st, 2)))
+    {
+        ShowWarning("script: buildin_getmapxy: not mapname variable\n");
+        script_pushint(st, -1);
+        return 1;
+    }
+    if (!data_isreference(script_getdata(st, 3)))
+    {
+        ShowWarning("script: buildin_getmapxy: not mapx variable\n");
+        script_pushint(st, -1);
+        return 1;
+    }
+    if (!data_isreference(script_getdata(st, 4)))
+    {
+        ShowWarning("script: buildin_getmapxy: not mapy variable\n");
+        script_pushint(st, -1);
+        return 1;
+    }
+
+    // Possible needly check function parameters on C_STR,C_INT,C_INT
+    type = script_getnum(st, 5);
+
+    switch (type)
+    {
+        case 0: //Get Character Position
+            if (script_hasdata(st, 6))
+                sd = map_nick2sd(script_getstr(st, 6));
+            else
+                sd=script_rid2sd(st);
+
+            if (sd)
+                bl = &sd->bl;
+            break;
+        case 1: //Get NPC Position
+            if (script_hasdata(st,6))
+            {
+                struct npc_data *nd;
+                nd = npc_name2id(script_getstr(st, 6));
+                if (nd)
+                    bl = &nd->bl;
+            }
+            else //In case the origin is not an npc?
+                bl = map_id2bl(st->oid);
+            break;
+        case 2: //Get Pet Position
+//            if(script_hasdata(st,6))
+//                sd=map_nick2sd(script_getstr(st,6));
+//            else
+//                sd=script_rid2sd(st);
+
+//            if (sd && sd->pd)
+//                bl = &sd->pd->bl;
+            break;
+        case 3: //Get Mob Position
+            break; //Not supported?
+        case 4: //Get Homun Position
+//            if(script_hasdata(st,6))
+//                sd=map_nick2sd(script_getstr(st,6));
+//            else
+//                sd=script_rid2sd(st);
+
+//            if (sd && sd->hd)
+//                bl = &sd->hd->bl;
+            break;
+    }
+    if (!bl)
+    { //No object found.
+        script_pushint(st,-1);
+        return 0;
+    }
+
+    x = bl->x;
+    y = bl->y;
+    memcpy(mapname, map[bl->m].name, MAP_NAME_LENGTH);
+
+    //Set MapName$
+    num = st->stack->stack_data[st->start+2].u.num;
+    name=(char *)(str_buf+str_data[num & 0x00ffffff].str);
+    prefix = *name;
+
+    if (not_server_variable(prefix))
+        sd = script_rid2sd(st);
+    else
+        sd = NULL;
+    set_reg(sd, num, name, (void*)mapname);
+//    set_reg(st, sd, num, name, (void*)mapname, script_getref(st, 2));
+
+    //Set MapX
+    num = st->stack->stack_data[st->start + 3].u.num;
+    name = (char *)(str_buf + str_data[num & 0x00ffffff].str);
+    prefix = *name;
+
+    if (not_server_variable(prefix))
+        sd = script_rid2sd(st);
+    else
+        sd = NULL;
+    set_reg(sd, num, name, (void*)x);
+//    set_reg(st, sd, num, name, (void*)x, script_getref(st, 3));
+
+    //Set MapY
+    num = st->stack->stack_data[st->start + 4].u.num;
+    name = (char *)(str_buf + str_data[num & 0x00ffffff].str);
+    prefix = *name;
+
+    if(not_server_variable(prefix))
+        sd = script_rid2sd(st);
+    else
+        sd = NULL;
+    set_reg(sd, num, name, (void*)y);
+//    set_reg(st, sd, num, name, (void*)y, script_getref(st, 4));
+
+    //Return Success value
+    script_pushint(st, 0);
+    return 0;
+}
+
+/*==========================================
  *     areatimer
  *------------------------------------------
  */
-- 
2.1.0

